# 03-使用指南

本文档提供 Galay Utils 的详细使用说明、最佳实践和常见场景。

## 模块选择指南

### 按使用场景选择

**字符串处理**:
- 数据解析：使用 String 模块的 split、trim
- 数据验证：使用 String 模块的 isInteger、isFloat
- 编码转换：使用 String 模块的 toHex、fromHex

**随机数生成**:
- 游戏开发：使用 Random 模块生成随机数
- 安全令牌：使用 Random 模块的 uuid、randomHex
- 数据采样：使用 Random 模块配合算法

**并发编程**:
- 任务并行：使用 ThreadPool
- 资源复用：使用 ObjectPool
- 限流控制：使用 RateLimiter

**网络服务**:
- API 限流：使用 RateLimiter
- 服务保护：使用 CircuitBreaker
- 负载均衡：使用 Balancer

**数据结构**:
- 前缀匹配：使用 TrieTree
- 分布式缓存：使用 ConsistentHash
- 版本控制：使用 Mvcc

## 核心工具使用指南

### String 模块

#### 1. 文本处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

void processLogLine(const std::string& line) {
    // 清理空白
    std::string cleaned = StringUtils::trim(line);

    // 分割字段
    auto fields = StringUtils::split(cleaned, '|');

    if (fields.size() >= 3) {
        std::string timestamp = fields[0];
        std::string level = StringUtils::toUpper(fields[1]);
        std::string message = fields[2];

        std::cout << "[" << timestamp << "] "
                  << level << ": " << message << '\n';
    }
}

int main() {
    std::string log = "  2024-01-01 10:00:00 | info | Server started  ";
    processLogLine(log);
    return 0;
}
```

#### 2. 配置文件解析

```cpp
#include <galay-utils/galay-utils.hpp>
#include <unordered_map>

using namespace galay::utils;

class ConfigParser {
public:
    void parse(const std::string& content) {
        auto lines = StringUtils::split(content, '\n');

        for (const auto& line : lines) {
            std::string trimmed = StringUtils::trim(line);

            // 跳过注释和空行
            if (trimmed.empty() || StringUtils::startsWith(trimmed, "#")) {
                continue;
            }

            // 解析键值对
            auto parts = StringUtils::split(trimmed, '=');
            if (parts.size() == 2) {
                std::string key = StringUtils::trim(parts[0]);
                std::string value = StringUtils::trim(parts[1]);
                m_config[key] = value;
            }
        }
    }

    std::string get(const std::string& key, const std::string& defaultValue = "") const {
        auto it = m_config.find(key);
        return it != m_config.end() ? it->second : defaultValue;
    }

private:
    std::unordered_map<std::string, std::string> m_config;
};

int main() {
    std::string config = R"(
        # Server configuration
        host = 127.0.0.1
        port = 8080

        # Database
        db_url = mysql://localhost:3306/mydb
    )";

    ConfigParser parser;
    parser.parse(config);

    std::cout << "Host: " << parser.get("host") << '\n';
    std::cout << "Port: " << parser.get("port") << '\n';

    return 0;
}
```

#### 3. 数据验证

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

bool validateInput(const std::string& input) {
    // 检查是否为空
    if (StringUtils::isBlank(input)) {
        std::cerr << "输入不能为空\n";
        return false;
    }

    // 检查长度
    if (input.length() < 3 || input.length() > 20) {
        std::cerr << "长度必须在 3-20 之间\n";
        return false;
    }

    // 检查是否包含非法字符
    if (StringUtils::contains(input, "<") || StringUtils::contains(input, ">")) {
        std::cerr << "包含非法字符\n";
        return false;
    }

    return true;
}

bool validateAge(const std::string& age) {
    if (!StringUtils::isInteger(age)) {
        std::cerr << "年龄必须是整数\n";
        return false;
    }

    int ageValue = std::stoi(age);
    if (ageValue < 0 || ageValue > 150) {
        std::cerr << "年龄超出范围\n";
        return false;
    }

    return true;
}
```

### Random 模块

#### 1. 游戏开发

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

class Game {
public:
    // 掷骰子
    int rollDice() {
        return Randomizer::instance().randomInt(1, 6);
    }

    // 生成随机地图
    std::vector<std::vector<int>> generateMap(int width, int height) {
        auto& rng = Randomizer::instance();
        std::vector<std::vector<int>> map(height, std::vector<int>(width));

        for (int y = 0; y < height; ++y) {
            for (int x = 0; x < width; ++x) {
                // 0: 空地, 1: 墙, 2: 宝箱
                double prob = rng.randomDouble(0.0, 1.0);
                if (prob < 0.7) {
                    map[y][x] = 0;  // 70% 空地
                } else if (prob < 0.95) {
                    map[y][x] = 1;  // 25% 墙
                } else {
                    map[y][x] = 2;  // 5% 宝箱
                }
            }
        }

        return map;
    }

    // 随机掉落物品
    std::string randomLoot() {
        auto& rng = Randomizer::instance();
        std::vector<std::string> items = {
            "金币", "药水", "武器", "护甲", "宝石"
        };

        int index = rng.randomInt(0, items.size() - 1);
        return items[index];
    }
};
```

#### 2. 测试数据生成

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

struct User {
    std::string id;
    std::string name;
    int age;
    std::string email;
};

class TestDataGenerator {
public:
    std::vector<User> generateUsers(size_t count) {
        auto& rng = Randomizer::instance();
        std::vector<User> users;

        std::vector<std::string> firstNames = {
            "Alice", "Bob", "Charlie", "David", "Eve"
        };
        std::vector<std::string> lastNames = {
            "Smith", "Johnson", "Williams", "Brown", "Jones"
        };

        for (size_t i = 0; i < count; ++i) {
            User user;
            user.id = rng.uuid();

            int firstIdx = rng.randomInt(0, firstNames.size() - 1);
            int lastIdx = rng.randomInt(0, lastNames.size() - 1);
            user.name = firstNames[firstIdx] + " " + lastNames[lastIdx];

            user.age = rng.randomInt(18, 65);

            std::string emailPrefix = StringUtils::toLower(user.name);
            emailPrefix = StringUtils::replace(emailPrefix, " ", ".");
            user.email = emailPrefix + "@example.com";

            users.push_back(user);
        }

        return users;
    }
};
```

### System 模块

#### 1. 系统监控

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <thread>
#include <chrono>

using namespace galay::utils;

class SystemMonitor {
public:
    void printSystemInfo() {
        std::cout << "=== System Information ===\n";
        std::cout << "Hostname: " << System::hostname() << '\n';
        std::cout << "CPU Cores: " << System::cpuCount() << '\n';
        std::cout << "Memory: " << System::memorySize() / (1024 * 1024) << " MB\n";
        std::cout << "Process ID: " << System::pid() << '\n';
        std::cout << "Username: " << System::username() << '\n';
    }

    void monitor(int seconds) {
        for (int i = 0; i < seconds; ++i) {
            int64_t now = System::timestamp();
            std::string timeStr = System::formatTime(now, "%Y-%m-%d %H:%M:%S");

            std::cout << "[" << timeStr << "] System running...\n";
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
};
```

#### 2. 文件操作

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

class FileManager {
public:
    bool saveData(const std::string& filename, const std::string& data) {
        if (System::writeFile(filename, data)) {
            std::cout << "数据已保存到 " << filename << '\n';
            return true;
        }
        std::cerr << "保存失败\n";
        return false;
    }

    std::string loadData(const std::string& filename) {
        if (!System::fileExists(filename)) {
            std::cerr << "文件不存在: " << filename << '\n';
            return "";
        }

        size_t size = System::fileSize(filename);
        std::cout << "文件大小: " << size << " 字节\n";

        return System::readFile(filename);
    }

    void listFiles(const std::string& pattern) {
        // 使用环境变量配置路径
        std::string basePath = System::getEnv("DATA_PATH");
        if (basePath.empty()) {
            basePath = "./data";
        }

        std::cout << "数据目录: " << basePath << '\n';
    }
};
```

## 并发编程使用指南

### ThreadPool 模块

#### 1. 并行任务处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>
#include <chrono>

using namespace galay::utils;

class ImageProcessor {
public:
    ImageProcessor() : m_pool(std::thread::hardware_concurrency()) {}

    void processImages(const std::vector<std::string>& images) {
        std::vector<std::future<bool>> futures;

        for (const auto& image : images) {
            auto future = m_pool.addTask([this, image]() {
                return processImage(image);
            });
            futures.push_back(std::move(future));
        }

        // 等待所有任务完成
        size_t success = 0;
        for (auto& future : futures) {
            if (future.get()) {
                success++;
            }
        }

        std::cout << "处理完成: " << success << "/" << images.size() << '\n';
    }

private:
    bool processImage(const std::string& image) {
        std::cout << "处理图片: " << image << '\n';
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
        return true;
    }

    ThreadPool m_pool;
};
```

#### 2. 批量数据处理

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

class DataProcessor {
public:
    DataProcessor(size_t numThreads) : m_pool(numThreads) {}

    std::vector<int> processData(const std::vector<int>& data) {
        const size_t chunkSize = 1000;
        std::vector<std::future<std::vector<int>>> futures;

        // 分块处理
        for (size_t i = 0; i < data.size(); i += chunkSize) {
            size_t end = std::min(i + chunkSize, data.size());

            auto future = m_pool.addTask([&data, i, end]() {
                std::vector<int> result;
                for (size_t j = i; j < end; ++j) {
                    result.push_back(data[j] * 2);  // 处理逻辑
                }
                return result;
            });

            futures.push_back(std::move(future));
        }

        // 合并结果
        std::vector<int> result;
        for (auto& future : futures) {
            auto chunk = future.get();
            result.insert(result.end(), chunk.begin(), chunk.end());
        }

        return result;
    }

private:
    ThreadPool m_pool;
};
```

### ObjectPool 模块

#### 1. 数据库连接池

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <memory>

using namespace galay::utils;

class DatabaseConnection {
public:
    DatabaseConnection(int id) : m_id(id) {
        std::cout << "创建连接 " << m_id << '\n';
    }

    ~DatabaseConnection() {
        std::cout << "销毁连接 " << m_id << '\n';
    }

    void execute(const std::string& sql) {
        std::cout << "连接 " << m_id << " 执行: " << sql << '\n';
    }

private:
    int m_id;
};

class DatabasePool {
public:
    DatabasePool(size_t poolSize)
        : m_pool([this]() { return createConnection(); }, poolSize) {}

    void executeQuery(const std::string& sql) {
        auto conn = m_pool.acquire();
        conn->execute(sql);
        // 自动归还到池中
    }

private:
    std::unique_ptr<DatabaseConnection> createConnection() {
        return std::make_unique<DatabaseConnection>(m_nextId++);
    }

    ObjectPool<DatabaseConnection> m_pool;
    int m_nextId = 0;
};
```

#### 2. 对象复用

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

class Buffer {
public:
    Buffer(size_t size) : m_data(size) {
        std::cout << "分配 " << size << " 字节\n";
    }

    ~Buffer() {
        std::cout << "释放 " << m_data.size() << " 字节\n";
    }

    void clear() {
        std::fill(m_data.begin(), m_data.end(), 0);
    }

    std::vector<uint8_t>& data() { return m_data; }

private:
    std::vector<uint8_t> m_data;
};

class BufferPool {
public:
    BufferPool(size_t bufferSize, size_t poolSize)
        : m_pool([bufferSize]() {
            return std::make_unique<Buffer>(bufferSize);
          }, poolSize) {}

    void processData(const std::vector<uint8_t>& input) {
        auto buffer = m_pool.acquire();
        buffer->clear();

        // 使用缓冲区处理数据
        auto& data = buffer->data();
        std::copy(input.begin(), input.end(), data.begin());

        // 处理完成，自动归还
    }

private:
    ObjectPool<Buffer> m_pool;
};
```

## 网络服务使用指南

### RateLimiter 模块

#### 1. API 限流

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <string>

using namespace galay::utils;

class APIServer {
public:
    APIServer()
        : m_limiter(100.0, 50) {}  // 每秒 100 个请求，容量 50

    bool handleRequest(const std::string& endpoint, const std::string& clientIp) {
        // 检查限流
        if (!m_limiter.tryAcquire(1)) {
            std::cerr << "请求被限流: " << clientIp << '\n';
            return false;
        }

        // 处理请求
        std::cout << "处理请求: " << endpoint << " from " << clientIp << '\n';
        return true;
    }

private:
    TokenBucketLimiter m_limiter;
};
```

#### 2. 用户级限流

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <unordered_map>
#include <memory>

using namespace galay::utils;

class UserRateLimiter {
public:
    UserRateLimiter(double ratePerUser, size_t capacity)
        : m_ratePerUser(ratePerUser), m_capacity(capacity) {}

    bool allowRequest(const std::string& userId) {
        auto it = m_limiters.find(userId);
        if (it == m_limiters.end()) {
            // 为新用户创建限流器
            auto limiter = std::make_unique<TokenBucketLimiter>(
                m_ratePerUser, m_capacity
            );
            it = m_limiters.emplace(userId, std::move(limiter)).first;
        }

        return it->second->tryAcquire(1);
    }

private:
    double m_ratePerUser;
    size_t m_capacity;
    std::unordered_map<std::string, std::unique_ptr<TokenBucketLimiter>> m_limiters;
};
```

### CircuitBreaker 模块

#### 1. 服务调用保护

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <stdexcept>

using namespace galay::utils;

class ExternalService {
public:
    ExternalService() {
        CircuitBreakerConfig config;
        config.failureThreshold = 5;
        config.successThreshold = 3;
        config.resetTimeout = std::chrono::seconds(30);
        m_breaker = std::make_unique<CircuitBreaker>(config);
    }

    std::string callAPI(const std::string& endpoint) {
        try {
            return m_breaker->execute([this, &endpoint]() {
                return doCallAPI(endpoint);
            });
        } catch (const std::exception& e) {
            std::cerr << "API 调用失败: " << e.what() << '\n';
            std::cerr << "熔断器状态: " << m_breaker->stateString() << '\n';
            throw;
        }
    }

    std::string callAPIWithFallback(const std::string& endpoint) {
        return m_breaker->executeWithFallback(
            [this, &endpoint]() { return doCallAPI(endpoint); },
            [&endpoint]() { return getCachedData(endpoint); }
        );
    }

private:
    std::string doCallAPI(const std::string& endpoint) {
        // 实际的 API 调用
        // 可能抛出异常
        return "API response";
    }

    std::string getCachedData(const std::string& endpoint) {
        // 从缓存获取数据
        return "Cached data";
    }

    std::unique_ptr<CircuitBreaker> m_breaker;
};
```

#### 2. 数据库访问保护

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

class DatabaseClient {
public:
    DatabaseClient() {
        CircuitBreakerConfig config;
        config.failureThreshold = 3;
        config.resetTimeout = std::chrono::seconds(10);
        m_breaker = std::make_unique<CircuitBreaker>(config);
    }

    bool query(const std::string& sql) {
        if (!m_breaker->allowRequest()) {
            std::cerr << "数据库熔断中，拒绝请求\n";
            return false;
        }

        try {
            // 执行查询
            bool success = executeQuery(sql);

            if (success) {
                m_breaker->onSuccess();
            } else {
                m_breaker->onFailure();
            }

            return success;
        } catch (const std::exception& e) {
            m_breaker->onFailure();
            throw;
        }
    }

private:
    bool executeQuery(const std::string& sql) {
        // 实际的数据库查询
        return true;
    }

    std::unique_ptr<CircuitBreaker> m_breaker;
};
```

### Balancer 模块

#### 1. 负载均衡

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

struct Server {
    std::string host;
    int port;

    std::string toString() const {
        return host + ":" + std::to_string(port);
    }
};

class LoadBalancer {
public:
    LoadBalancer(const std::vector<Server>& servers)
        : m_roundRobin(servers) {}

    std::string sendRequest(const std::string& request) {
        auto server = m_roundRobin.select();
        if (!server) {
            std::cerr << "没有可用的服务器\n";
            return "";
        }

        std::cout << "发送请求到: " << server->toString() << '\n';
        // 实际发送请求
        return "Response from " + server->toString();
    }

private:
    RoundRobinLoadBalancer<Server> m_roundRobin;
};
```

#### 2. 加权负载均衡

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>

using namespace galay::utils;

class WeightedLoadBalancer {
public:
    WeightedLoadBalancer(
        const std::vector<Server>& servers,
        const std::vector<uint32_t>& weights
    ) : m_balancer(servers, weights) {}

    void distributeRequests(size_t count) {
        std::unordered_map<std::string, size_t> distribution;

        for (size_t i = 0; i < count; ++i) {
            auto server = m_balancer.select();
            if (server) {
                distribution[server->toString()]++;
            }
        }

        std::cout << "请求分布:\n";
        for (const auto& [server, count] : distribution) {
            std::cout << server << ": " << count << " 请求\n";
        }
    }

private:
    WeightRoundRobinLoadBalancer<Server> m_balancer;
};
```

## 数据结构使用指南

### TrieTree 模块

#### 1. 自动补全

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <vector>

using namespace galay::utils;

class AutoComplete {
public:
    void addWord(const std::string& word) {
        m_trie.insert(word);
    }

    std::vector<std::string> suggest(const std::string& prefix) {
        if (!m_trie.startsWith(prefix)) {
            return {};
        }

        // 这里简化处理，实际需要遍历 Trie 树
        std::vector<std::string> suggestions;
        // ... 实现建议逻辑
        return suggestions;
    }

    bool isValidWord(const std::string& word) {
        return m_trie.search(word);
    }

private:
    TrieTree m_trie;
};
```

### ConsistentHash 模块

#### 1. 分布式缓存

```cpp
#include <galay-utils/galay-utils.hpp>
#include <iostream>
#include <unordered_map>

using namespace galay::utils;

class DistributedCache {
public:
    DistributedCache(const std::vector<std::string>& servers)
        : m_hash(150) {
        for (const auto& server : servers) {
            m_hash.addNode(server);
        }
    }

    void set(const std::string& key, const std::string& value) {
        auto server = m_hash.getNode(key);
        if (server) {
            std::cout << "SET " << key << " -> " << *server << '\n';
            // 实际发送到服务器
        }
    }

    std::string get(const std::string& key) {
        auto server = m_hash.getNode(key);
        if (server) {
            std::cout << "GET " << key << " -> " << *server << '\n';
            // 实际从服务器获取
            return "value";
        }
        return "";
    }

    void addServer(const std::string& server) {
        m_hash.addNode(server);
        std::cout << "添加服务器: " << server << '\n';
    }

    void removeServer(const std::string& server) {
        m_hash.removeNode(server);
        std::cout << "移除服务器: " << server << '\n';
    }

private:
    ConsistentHash<std::string> m_hash;
};
```

## 最佳实践

### 1. 错误处理

```cpp
// 使用 try-catch 处理异常
try {
    auto result = processData(input);
} catch (const std::exception& e) {
    std::cerr << "处理失败: " << e.what() << '\n';
    // 记录日志、清理资源等
}
```

### 2. 资源管理

```cpp
// 使用 RAII 管理资源
{
    auto buffer = pool.acquire();
    // 使用 buffer
    // 析构时自动归还
}
```

### 3. 线程安全

```cpp
// 使用互斥锁保护共享数据
std::mutex mutex;
std::lock_guard<std::mutex> lock(mutex);
// 访问共享数据
```

### 4. 性能优化

```cpp
// 预留空间避免多次分配
std::vector<int> data;
data.reserve(10000);

// 使用移动语义避免拷贝
auto result = std::move(largeObject);
```

## 下一步

- [示例代码](04-示例代码.md) - 更多实用示例
- [性能测试](05-性能测试.md) - 性能基准和优化
- [高级主题](06-高级主题.md) - 高级功能和优化
- [常见问题](07-常见问题.md) - 常见问题解答
